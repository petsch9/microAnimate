{"version":3,"sources":["../src/esAnimate.js"],"names":[],"mappings":"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","file":"esAnimate-es5.js","sourcesContent":["\"use strict\";\n\n(function(window) {\n\n    let microAnimate = class {\n        constructor(\n            element,\n            animation = {},\n            options = {\n                duration: 2000,\n                ease: true,\n                retainEndState: true,\n                loop: 0\n            }\n        ) {\n            //Process the Animation/Options and store them\n            this.element = element;\n            this.options = options;\n            //Constants\n            this.data = {\n                //tickLength constant (default: 16)\n                tickLength: 16,\n                //Action can be: 0=nothing, 1=pause or 2=unpause\n                action: 0\n            };\n            this.data.tickTotal = Math.ceil(options.duration / this.data.tickLength);\n            this.animation = processAnimation(\n                preprocessAnimation(animation),\n                this.data,\n                this.options\n            );\n            this.interval = null;\n\n\n\n            /*The Animation gets calculated before when constructed for better performance\n             * Generate Style, Transition and Callbacks from the animation property\n             */\n            function processAnimation(animation, data, options) {\n                let result = {\n                    initial: {},\n                    index: Object.keys(animation)\n                };\n\n\n                //Initial State\n                result.initial.styles = mapAnimation(animation[0], animation[0]);\n\n                //Go over each percentage given\n                result.index.forEach((key, index) => {\n                    result[key] = {};\n\n                    //The next key of the Animation\n                    const animationNext = animation[result.index[index + 1]],\n                        //Time between the current and the next key (or the two before if not given)\n                        timeDifference =\n                        (((options.duration * (result.index[index] - result.index[index - 1]) / 100) / 1000) ||\n                            0) + \"s\";\n\n                    result[key].styles = mapAnimation(animation[key]);\n                    result[key].transition = mapTransition(animation[key], timeDifference, options.ease);\n                    result[key].callback = mapCallback(animation[key]);\n                });\n\n                return result;\n\n\n\n                /*\n                 * Mapping Sub-functions\n                 */\n\n                //Maps Animation\n                function mapAnimation(animation) {\n                    let result = [];\n\n                    //Iterate over styles\n                    animation.forEach(style => {\n                        if (typeof style === \"object\") {\n                            result.push(style);\n                        }\n                    });\n                    return result;\n                }\n\n\n\n                //Maps Transitions\n                function mapTransition(animation, timeDifference, ease) {\n                    let result = [],\n                        //Additional transition values like \"ease\"\n                        add = \"\";\n\n                    //Ease if easing is enabled (either default or given easing)\n                    if (ease === true || typeof ease === \"string\") {\n                        if (typeof ease === \"string\") {\n                            //if a string is given, use the string\n                            add = \" \" + ease;\n                        } else {\n                            //if a true is given, use default easing\n                            add = \" ease\";\n                        }\n                    } else {\n                        //if a false is given, use no easing\n                        add = \" linear\";\n                    }\n\n                    //Iterate over styles\n                    animation.forEach((style, index) => {\n                        if (typeof style === \"object\") {\n                            let transition;\n\n                            //Transition String\n                            if (typeof animation !== \"undefined\") {\n                                //Generate CSS transition\n                                transition = animation[index][0] + \" \" + timeDifference + add;\n                            } else {\n                                transition = \"\";\n                            }\n                            result.push(transition);\n\n                        }\n                    });\n\n                    return result;\n                }\n\n\n                //Maps Callbacks\n                function mapCallback(animation) {\n                    let result;\n\n                    //Iterate over callbacks\n                    animation.forEach(fn => {\n                        if (typeof fn === \"function\") {\n                            result = fn;\n                        }\n                    });\n                    return result;\n                }\n\n            }\n\n            /* Sort and format Animation object\n             *\n             * + Converts \"from\" to \"0\" and \"to\" to \"100\"\n             * + converts \"100\" to 100 etc.\n             *\n             */\n            function preprocessAnimation(animation) {\n                let optimizedKeys = [],\n                    result = {};\n\n                //Go over keys and replace \"from\" and \"to\"\n                Object.keys(animation).forEach(keyName => {\n                    if (keyName === \"from\") {\n                        animation[\"0%\"] = animation[keyName];\n                        delete animation[keyName];\n                    } else if (keyName === \"to\") {\n                        animation[\"100%\"] = animation[keyName];\n                        delete animation[keyName];\n                    }\n                });\n\n\n                //Sort Keys in a new Array (we need to \".keys() \" again because we modified the keys before)\n                optimizedKeys = Object.keys(animation);\n                optimizedKeys.forEach((keyName, index) => {\n                    optimizedKeys[index] = parseInt(keyName.replace(\"%\", \"\"));\n                });\n                optimizedKeys.sort();\n\n                //Sort Object\n                optimizedKeys.forEach(keyName => {\n                    result[keyName] = animation[keyName + \"%\"];\n                });\n\n\n                return result;\n            }\n\n        }\n\n\n        /*\n         * Internal functions\n         */\n\n        //Resets the element to its default style\n        reset(element) {\n            //Kind of rough but it works\n            element.style.cssText = \"\";\n        }\n\n        //Clear Animation\n        kill(forceReset) {\n            window.clearInterval(this.interval);\n            this.interval = null;\n            if (!this.options.retainEndState || forceReset) {\n                this.reset(this.element);\n            }\n        }\n\n\n        /*\n         * Animation methods\n         */\n\n        //Main Animation play-method\n        start() {\n            //Reset if the Animation is called while its already running\n            if (this.interval !== null) {\n                this.kill.apply(this, [true]);\n            }\n            //shorteners\n            let _self = this,\n                _animation = _self.animation,\n                _data = _self.data,\n                //Other vars\n                indexMin,\n                indexList,\n                //Loop object that stores the current and the maximum iterations\n                loop = {\n                    current: 1,\n                    max: (typeof this.options.loop === \"boolean\" ? (\n                        this.options.loop ? Infinity : 0\n                    ) : this.options.loop)\n                };\n            _data.relativePercentage = 0;\n            _data.tickCurrent=0;\n\n            //Reset Element\n            this.reset(_self.element);\n            animationReset();\n\n            //Start the animation\n            animationLoop(_self);\n\n\n            //Main Animation Interval\n            function animationLoop() {\n                _data.relativePercentage = Math.round((100 / _data.tickTotal) * _data.tickCurrent);\n\n                //Remove the interval if over 100% else Animate\n                if (indexList.length === 0) {\n                    //Check if given loops have been run and if the animation an be terminated\n                    if (loop.current < loop.max) {\n\n                        _self.reset(_self.element);\n                        animationReset();\n                        loop.current++;\n                        animationLoop();\n                    } else {\n                        //terminate animation\n                        this.kill.apply(this, [false]);\n                    }\n                } else {\n                    //console.log(\"Animation Progress: \" + _data.relativePercentage + \"%\");\n                    //Animate if there is data for the current percentage\n                    if (_data.relativePercentage > indexMin) {\n                        //Get the data of the current and the next frame\n                        let currentFrame = _animation[indexMin],\n                            nextFrame = _animation[indexList[1]] || _animation[0];\n                        //Remove smallest Index and recalc\n                        indexList.shift();\n                        //Get smallest value of Array\n                        indexMin = Math.min.apply(Math, indexList);\n\n                        //Animate the Style for the NEXT frame\n                        applyTransition(\n                            _self.element,\n                            nextFrame.transition\n                        );\n                        applyAnimation(\n                            _self.element,\n                            nextFrame.styles\n                        );\n                        //Run the callback for the CURRENT frame\n                        if (typeof currentFrame.callback !== \"undefined\") {\n                            applyCallback(\n                                currentFrame.callback,\n                                _self\n                            );\n                        }\n                    }\n\n                    _data.tickCurrent++;\n                    //Check if theres anything to do before going to the next frame (pausing etc.)\n                    if (_data.action === 0) {\n                        //Ooooor everything is nice and quiet, and we can continue our animation\n                        _self.interval = window.setTimeout(() => {\n                            window.requestAnimationFrame(animationLoop);\n                        }, _data.tickLength);\n                    } else if (_data.action === 1) {\n                        //Pause Controller\n                        //Wait for unpause\n                        animationPause();\n                    }\n                }\n            }\n\n\n            /*\n             * Sub-functions used in the active Animation\n             */\n\n            //Apply all styles for the current Frame\n            function applyAnimation(element, styles) {\n                if (typeof styles !== \"undefined\") {\n                    for (let i = 0; i < styles.length; i++) {\n                        element.style[styles[i][0]] = styles[i][1];\n                    }\n                }\n            }\n\n            //Run Transitions if needed\n            function applyTransition(element, transitions) {\n                if (typeof transitions !== \"undefined\") {\n                    element.style.transition = transitions.join(\", \");\n                }\n            }\n\n            //Check if any callbacks need to be run\n            function applyCallback(callback, context) {\n                callback(context);\n            }\n\n            //Reset animation\n            function animationReset() {\n                indexMin = 0;\n                indexList = Array.from(_animation.index);\n                _data.tickCurrent = 0;\n                _data.relativePercentage = 0;\n                _data.action = 0;\n\n                applyAnimation(\n                    _self.element,\n                    _animation.initial.styles\n                );\n            }\n\n\n            function animationPause() {\n                _self.interval = window.setInterval(() => {\n                    if (_data.action === 2) {\n                        //Yay we can continue\n                        _data.action = 0;\n                        window.clearInterval(_self.interval);\n                        window.requestAnimationFrame(animationLoop);\n                    }\n                }, _data.tickLength * 2);\n            }\n\n        }\n\n        //Pause Animation\n        pause() {\n                this.data.action = 1;\n            }\n\n        //Resume paused Animation\n        unpause() {\n            if (this.data.action === 1) {\n                this.data.action = 2;\n            }\n        }\n\n        //Stop & Reset Animation\n        stop() {\n            this.kill.apply(this, [true]);\n        }\n    };\n\n\n    //Export full namespace to global scope\n    window.microAnimate = microAnimate;\n    //Exports shorter namespace\n    window.Anim = microAnimate;\n\n})(window);\n"]}