{"version":3,"sources":["../src/microAnimate.js"],"names":[],"mappings":"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","file":"microAnimate.js","sourcesContent":["\"use strict\";\n\n(function(window) {\n\n    let microAnimate = class {\n        constructor(\n            element,\n            animation = {},\n            options = {\n                duration: 2000,\n                ease: true,\n                retainEndState: true,\n                loop: 0\n            }\n        ) {\n            //Process the Animation/Options and store them\n            this.element = element;\n            this.options = options;\n            //Constants\n            this.data = {\n                //tickLength constant (default: 16)\n                tickLength: 16,\n                //Action can be: 0=nothing, 1=pause or 2=unpause\n                action: 0\n            };\n            this.data.tickTotal = Math.ceil(options.duration / this.data.tickLength);\n            this.animation = processAnimation(\n                preprocessAnimation(animation),\n                this.data,\n                this.options\n            );\n            this.interval = null;\n\n\n\n            /*The Animation gets calculated before when constructed for better performance\n             * Generate Style, Transition and Callbacks from the animation property\n             */\n            function processAnimation(animation, data, options) {\n                let result = {\n                    initial: {},\n                    index: Object.keys(animation)\n                };\n\n\n                //Initial State\n                result.initial.styles = mapAnimation(animation[0], animation[0]);\n\n                //Go over each percentage given\n                result.index.forEach((key, index) => {\n                    result[key] = {};\n\n                    //The next key of the Animation\n                    const animationNext = animation[result.index[index + 1]],\n                        //Time between the current and the next key (or the two before if not given)\n                        timeDifference =\n                        (((options.duration * (result.index[index] - result.index[index - 1]) / 100) / 1000) ||\n                            0) + \"s\";\n\n                    result[key].styles = mapAnimation(animation[key]);\n                    result[key].transition = mapTransition(animation[key], timeDifference, options.ease);\n                    result[key].callback = mapCallback(animation[key]);\n                });\n\n                return result;\n\n\n\n                /*\n                 * Mapping Sub-functions\n                 */\n\n                //Maps Animation\n                function mapAnimation(animation) {\n                    let result = [];\n\n                    //Iterate over styles\n                    animation.forEach(style => {\n                        if (typeof style === \"object\") {\n                            result.push(style);\n                        }\n                    });\n                    return result;\n                }\n\n\n\n                //Maps Transitions\n                function mapTransition(animation, timeDifference, ease) {\n                    let result = [],\n                        //Additional transition values like \"ease\"\n                        add = \"\";\n\n                    //Ease if easing is enabled (either default or given easing)\n                    if (ease === true || typeof ease === \"string\") {\n                        if (typeof ease === \"string\") {\n                            //if a string is given, use the string\n                            add = \" \" + ease;\n                        } else {\n                            //if a true is given, use default easing\n                            add = \" ease\";\n                        }\n                    } else {\n                        //if a false is given, use no easing\n                        add = \" linear\";\n                    }\n\n                    //Iterate over styles\n                    animation.forEach((style, index) => {\n                        if (typeof style === \"object\") {\n                            let transition;\n\n                            //Transition String\n                            if (typeof animation !== \"undefined\") {\n                                //Generate CSS transition\n                                transition = animation[index][0] + \" \" + timeDifference + add;\n                            } else {\n                                transition = \"\";\n                            }\n                            result.push(transition);\n\n                        }\n                    });\n\n                    return result;\n                }\n\n\n                //Maps Callbacks\n                function mapCallback(animation) {\n                    let result;\n\n                    //Iterate over callbacks\n                    animation.forEach(fn => {\n                        if (typeof fn === \"function\") {\n                            result = fn;\n                        }\n                    });\n                    return result;\n                }\n\n            }\n\n            /* Sort and format Animation object\n             *\n             * + Converts \"from\" to \"0\" and \"to\" to \"100\"\n             * + converts \"100\" to 100 etc.\n             *\n             */\n            function preprocessAnimation(animation) {\n                let optimizedKeys = [],\n                    result = {};\n\n                //Go over keys and replace \"from\" and \"to\"\n                Object.keys(animation).forEach(keyName => {\n                    if (keyName === \"from\") {\n                        animation[\"0%\"] = animation[keyName];\n                        delete animation[keyName];\n                    } else if (keyName === \"to\") {\n                        animation[\"100%\"] = animation[keyName];\n                        delete animation[keyName];\n                    }\n                });\n\n\n                //Sort Keys in a new Array (we need to \".keys() \" again because we modified the keys before)\n                optimizedKeys = Object.keys(animation);\n                optimizedKeys.forEach((keyName, index) => {\n                    optimizedKeys[index] = parseInt(keyName.replace(\"%\", \"\"));\n                });\n                optimizedKeys.sort();\n\n                //Sort Object\n                optimizedKeys.forEach(keyName => {\n                    result[keyName] = animation[keyName + \"%\"];\n                });\n\n\n                return result;\n            }\n\n        }\n\n\n        /*\n         * Internal functions\n         */\n\n        //Resets the element to its default style\n        reset(element) {\n            //Kind of rough but it works\n            element.style.cssText = \"\";\n        }\n\n        //Clear Animation\n        kill(forceReset) {\n            window.clearInterval(this.interval);\n            this.interval = null;\n            if (!this.options.retainEndState || forceReset) {\n                this.reset(this.element);\n            }\n        }\n\n\n        /*\n         * Animation methods\n         */\n\n        //Main Animation play-method\n        start() {\n            //Reset if the Animation is called while its already running\n            if (this.interval !== null) {\n                this.kill.apply(this, [true]);\n            }\n            //shorteners\n            let _self = this,\n                _animation = _self.animation,\n                _data = _self.data,\n                //Other vars\n                indexMin,\n                indexList,\n                //Loop object that stores the current and the maximum iterations\n                loop = {\n                    current: 1,\n                    max: (typeof this.options.loop === \"boolean\" ? (\n                        this.options.loop ? Infinity : 0\n                    ) : this.options.loop)\n                };\n            _data.relativePercentage = 0;\n            _data.tickCurrent=0;\n\n            //Reset Element\n            this.reset(_self.element);\n            animationReset();\n\n            //Start the animation\n            animationLoop(_self);\n\n\n            //Main Animation Interval\n            function animationLoop() {\n                _data.relativePercentage = Math.round((100 / _data.tickTotal) * _data.tickCurrent);\n\n                //Remove the interval if over 100% else Animate\n                if (indexList.length === 0) {\n                    //Check if given loops have been run and if the animation an be terminated\n                    if (loop.current < loop.max) {\n\n                        _self.reset(_self.element);\n                        animationReset();\n                        loop.current++;\n                        animationLoop();\n                    } else {\n                        //terminate animation\n                        this.kill.apply(this, [false]);\n                    }\n                } else {\n                    //console.log(\"Animation Progress: \" + _data.relativePercentage + \"%\");\n                    //Animate if there is data for the current percentage\n                    if (_data.relativePercentage > indexMin) {\n                        //Get the data of the current and the next frame\n                        let currentFrame = _animation[indexMin],\n                            nextFrame = _animation[indexList[1]] || _animation[0];\n                        //Remove smallest Index and recalc\n                        indexList.shift();\n                        //Get smallest value of Array\n                        indexMin = Math.min.apply(Math, indexList);\n\n                        //Animate the Style for the NEXT frame\n                        applyTransition(\n                            _self.element,\n                            nextFrame.transition\n                        );\n                        applyAnimation(\n                            _self.element,\n                            nextFrame.styles\n                        );\n                        //Run the callback for the CURRENT frame\n                        if (typeof currentFrame.callback !== \"undefined\") {\n                            applyCallback(\n                                currentFrame.callback,\n                                _self\n                            );\n                        }\n                    }\n\n                    _data.tickCurrent++;\n                    //Check if theres anything to do before going to the next frame (pausing etc.)\n                    if (_data.action === 0) {\n                        //Ooooor everything is nice and quiet, and we can continue our animation\n                        _self.interval = window.setTimeout(() => {\n                            window.requestAnimationFrame(animationLoop);\n                        }, _data.tickLength);\n                    } else if (_data.action === 1) {\n                        //Pause Controller\n                        //Wait for unpause\n                        animationPause();\n                    }\n                }\n            }\n\n\n            /*\n             * Sub-functions used in the active Animation\n             */\n\n            //Apply all styles for the current Frame\n            function applyAnimation(element, styles) {\n                if (typeof styles !== \"undefined\") {\n                    for (let i = 0; i < styles.length; i++) {\n                        element.style[styles[i][0]] = styles[i][1];\n                    }\n                }\n            }\n\n            //Run Transitions if needed\n            function applyTransition(element, transitions) {\n                if (typeof transitions !== \"undefined\") {\n                    element.style.transition = transitions.join(\", \");\n                }\n            }\n\n            //Check if any callbacks need to be run\n            function applyCallback(callback, context) {\n                callback(context);\n            }\n\n            //Reset animation\n            function animationReset() {\n                indexMin = 0;\n                indexList = Array.from(_animation.index);\n                _data.tickCurrent = 0;\n                _data.relativePercentage = 0;\n                _data.action = 0;\n\n                applyAnimation(\n                    _self.element,\n                    _animation.initial.styles\n                );\n            }\n\n\n            function animationPause() {\n                _self.interval = window.setInterval(() => {\n                    if (_data.action === 2) {\n                        //Yay we can continue\n                        _data.action = 0;\n                        window.clearInterval(_self.interval);\n                        window.requestAnimationFrame(animationLoop);\n                    }\n                }, _data.tickLength * 2);\n            }\n\n        }\n\n        //Pause Animation\n        pause() {\n                this.data.action = 1;\n            }\n\n        //Resume paused Animation\n        unpause() {\n            if (this.data.action === 1) {\n                this.data.action = 2;\n            }\n        }\n\n        //Stop & Reset Animation\n        stop() {\n            this.kill.apply(this, [true]);\n        }\n    };\n\n\n    //Export full namespace to global scope\n    window.microAnimate = microAnimate;\n    //Exports shorter namespace\n    window.Anim = microAnimate;\n\n})(window);\n"]}